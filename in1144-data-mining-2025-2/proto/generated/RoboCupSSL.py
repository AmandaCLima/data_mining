# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: ssl_vision_detection.proto, ssl_vision_geometry.proto, ssl_vision_wrapper.proto, ssl_gc_common.proto, ssl_gc_geometry.proto, ssl_gc_game_event.proto, ssl_gc_referee_message.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto


class SSL_FieldShapeType(betterproto.Enum):
    Undefined = 0
    CenterCircle = 1
    TopTouchLine = 2
    BottomTouchLine = 3
    LeftGoalLine = 4
    RightGoalLine = 5
    HalfwayLine = 6
    CenterLine = 7
    LeftPenaltyStretch = 8
    RightPenaltyStretch = 9
    LeftFieldLeftPenaltyStretch = 10
    LeftFieldRightPenaltyStretch = 11
    RightFieldLeftPenaltyStretch = 12
    RightFieldRightPenaltyStretch = 13


class Team(betterproto.Enum):
    """Team is either blue or yellow"""

    # team not set
    UNKNOWN = 0
    # yellow team
    YELLOW = 1
    # blue team
    BLUE = 2


class Division(betterproto.Enum):
    """Division denotes the current division, which influences some rules"""

    DIV_UNKNOWN = 0
    DIV_A = 1
    DIV_B = 2


class GameEventType(betterproto.Enum):
    UNKNOWN_GAME_EVENT_TYPE = 0
    BALL_LEFT_FIELD_TOUCH_LINE = 6
    BALL_LEFT_FIELD_GOAL_LINE = 7
    AIMLESS_KICK = 11
    ATTACKER_TOO_CLOSE_TO_DEFENSE_AREA = 19
    DEFENDER_IN_DEFENSE_AREA = 31
    BOUNDARY_CROSSING = 41
    KEEPER_HELD_BALL = 13
    BOT_DRIBBLED_BALL_TOO_FAR = 17
    BOT_PUSHED_BOT = 24
    BOT_HELD_BALL_DELIBERATELY = 26
    BOT_TIPPED_OVER = 27
    ATTACKER_TOUCHED_BALL_IN_DEFENSE_AREA = 15
    BOT_KICKED_BALL_TOO_FAST = 18
    BOT_CRASH_UNIQUE = 22
    BOT_CRASH_DRAWN = 21
    DEFENDER_TOO_CLOSE_TO_KICK_POINT = 29
    BOT_TOO_FAST_IN_STOP = 28
    BOT_INTERFERED_PLACEMENT = 20
    POSSIBLE_GOAL = 39
    GOAL = 8
    INVALID_GOAL = 42
    ATTACKER_DOUBLE_TOUCHED_BALL = 14
    PLACEMENT_SUCCEEDED = 5
    PENALTY_KICK_FAILED = 43
    NO_PROGRESS_IN_GAME = 2
    PLACEMENT_FAILED = 3
    MULTIPLE_CARDS = 32
    MULTIPLE_FOULS = 34
    BOT_SUBSTITUTION = 37
    TOO_MANY_ROBOTS = 38
    CHALLENGE_FLAG = 44
    EMERGENCY_STOP = 45
    UNSPORTING_BEHAVIOR_MINOR = 35
    UNSPORTING_BEHAVIOR_MAJOR = 36
    PREPARED = 1
    INDIRECT_GOAL = 9
    CHIPPED_GOAL = 10
    KICK_TIMEOUT = 12
    ATTACKER_TOUCHED_OPPONENT_IN_DEFENSE_AREA = 16
    ATTACKER_TOUCHED_OPPONENT_IN_DEFENSE_AREA_SKIPPED = 40
    BOT_CRASH_UNIQUE_SKIPPED = 23
    BOT_PUSHED_BOT_SKIPPED = 25
    DEFENDER_IN_DEFENSE_AREA_PARTIALLY = 30
    MULTIPLE_PLACEMENT_FAILURES = 33


class RefereeStage(betterproto.Enum):
    NORMAL_FIRST_HALF_PRE = 0
    NORMAL_FIRST_HALF = 1
    NORMAL_HALF_TIME = 2
    NORMAL_SECOND_HALF_PRE = 3
    NORMAL_SECOND_HALF = 4
    EXTRA_TIME_BREAK = 5
    EXTRA_FIRST_HALF_PRE = 6
    EXTRA_FIRST_HALF = 7
    EXTRA_HALF_TIME = 8
    EXTRA_SECOND_HALF_PRE = 9
    EXTRA_SECOND_HALF = 10
    PENALTY_SHOOTOUT_BREAK = 11
    PENALTY_SHOOTOUT = 12
    POST_GAME = 13


class RefereeCommand(betterproto.Enum):
    HALT = 0
    STOP = 1
    NORMAL_START = 2
    FORCE_START = 3
    PREPARE_KICKOFF_YELLOW = 4
    PREPARE_KICKOFF_BLUE = 5
    PREPARE_PENALTY_YELLOW = 6
    PREPARE_PENALTY_BLUE = 7
    DIRECT_FREE_YELLOW = 8
    DIRECT_FREE_BLUE = 9
    INDIRECT_FREE_YELLOW = 10
    INDIRECT_FREE_BLUE = 11
    TIMEOUT_YELLOW = 12
    TIMEOUT_BLUE = 13
    GOAL_YELLOW = 14
    GOAL_BLUE = 15
    BALL_PLACEMENT_YELLOW = 16
    BALL_PLACEMENT_BLUE = 17


@dataclass
class SSL_DetectionBall(betterproto.Message):
    confidence: float = betterproto.float_field(1)
    area: int = betterproto.uint32_field(2)
    x: float = betterproto.float_field(3)
    y: float = betterproto.float_field(4)
    z: float = betterproto.float_field(5)
    pixel_x: float = betterproto.float_field(6)
    pixel_y: float = betterproto.float_field(7)


@dataclass
class SSL_DetectionRobot(betterproto.Message):
    confidence: float = betterproto.float_field(1)
    robot_id: int = betterproto.uint32_field(2)
    x: float = betterproto.float_field(3)
    y: float = betterproto.float_field(4)
    orientation: float = betterproto.float_field(5)
    pixel_x: float = betterproto.float_field(6)
    pixel_y: float = betterproto.float_field(7)
    height: float = betterproto.float_field(8)


@dataclass
class SSL_DetectionFrame(betterproto.Message):
    frame_number: int = betterproto.uint32_field(1)
    t_capture: float = betterproto.double_field(2)
    t_sent: float = betterproto.double_field(3)
    camera_id: int = betterproto.uint32_field(4)
    balls: List["SSL_DetectionBall"] = betterproto.message_field(5)
    robots_yellow: List["SSL_DetectionRobot"] = betterproto.message_field(6)
    robots_blue: List["SSL_DetectionRobot"] = betterproto.message_field(7)


@dataclass
class Vector2f(betterproto.Message):
    """A 2D float vector."""

    # X-coordinate in mm
    x: float = betterproto.float_field(1)
    # Y-coordinate in mm
    y: float = betterproto.float_field(2)


@dataclass
class SSL_FieldLineSegment(betterproto.Message):
    """
    Represents a field marking as a line segment represented by a start point
    p1, and end point p2, and a line thickness. The start and end points are
    along the center of the line, so the thickness of the line extends by
    thickness / 2 on either side of the line.
    """

    # Name of this field marking.
    name: str = betterproto.string_field(1)
    # Start point of the line segment.
    p1: "Vector2f" = betterproto.message_field(2)
    # End point of the line segment.
    p2: "Vector2f" = betterproto.message_field(3)
    # Thickness of the line segment.
    thickness: float = betterproto.float_field(4)
    # The type of this shape
    type: "SSL_FieldShapeType" = betterproto.enum_field(5)


@dataclass
class SSL_FieldCircularArc(betterproto.Message):
    """
    Represents a field marking as a circular arc segment represented by center
    point, a start angle, an end angle, and an arc thickness.
    """

    # Name of this field marking.
    name: str = betterproto.string_field(1)
    # Center point of the circular arc.
    center: "Vector2f" = betterproto.message_field(2)
    # Radius of the arc.
    radius: float = betterproto.float_field(3)
    # Start angle in counter-clockwise order.
    a1: float = betterproto.float_field(4)
    # End angle in counter-clockwise order.
    a2: float = betterproto.float_field(5)
    # Thickness of the arc.
    thickness: float = betterproto.float_field(6)
    # The type of this shape
    type: "SSL_FieldShapeType" = betterproto.enum_field(7)


@dataclass
class SSL_GeometryFieldSize(betterproto.Message):
    # Field length (distance between goal lines) in mm
    field_length: int = betterproto.int32_field(1)
    # Field width (distance between touch lines) in mm
    field_width: int = betterproto.int32_field(2)
    # Goal width (distance between inner edges of goal posts) in mm
    goal_width: int = betterproto.int32_field(3)
    # Goal depth (distance from outer goal line edge to inner goal back) in mm
    goal_depth: int = betterproto.int32_field(4)
    # Boundary width (distance from touch/goal line centers to boundary walls) in
    # mm
    boundary_width: int = betterproto.int32_field(5)
    # Generated line segments based on the other parameters
    field_lines: List["SSL_FieldLineSegment"] = betterproto.message_field(6)
    # Generated circular arcs based on the other parameters
    field_arcs: List["SSL_FieldCircularArc"] = betterproto.message_field(7)
    # Depth of the penalty/defense area (measured between line centers) in mm
    penalty_area_depth: int = betterproto.int32_field(8)
    # Width of the penalty/defense area (measured between line centers) in mm
    penalty_area_width: int = betterproto.int32_field(9)
    # Radius of the center circle (measured between line centers) in mm
    center_circle_radius: int = betterproto.int32_field(10)
    # Thickness/width of the lines on the field in mm
    line_thickness: int = betterproto.int32_field(11)
    # Distance between the goal center and the center of the penalty mark in mm
    goal_center_to_penalty_mark: int = betterproto.int32_field(12)
    # Goal height in mm
    goal_height: int = betterproto.int32_field(13)
    # Ball radius in mm (note that this is a float type to represent sub-mm
    # precision)
    ball_radius: float = betterproto.float_field(14)
    # Max allowed robot radius in mm (note that this is a float type to represent
    # sub-mm precision)
    max_robot_radius: float = betterproto.float_field(15)


@dataclass
class SSL_GeometryCameraCalibration(betterproto.Message):
    camera_id: int = betterproto.uint32_field(1)
    focal_length: float = betterproto.float_field(2)
    principal_point_x: float = betterproto.float_field(3)
    principal_point_y: float = betterproto.float_field(4)
    distortion: float = betterproto.float_field(5)
    q0: float = betterproto.float_field(6)
    q1: float = betterproto.float_field(7)
    q2: float = betterproto.float_field(8)
    q3: float = betterproto.float_field(9)
    tx: float = betterproto.float_field(10)
    ty: float = betterproto.float_field(11)
    tz: float = betterproto.float_field(12)
    derived_camera_world_tx: float = betterproto.float_field(13)
    derived_camera_world_ty: float = betterproto.float_field(14)
    derived_camera_world_tz: float = betterproto.float_field(15)
    pixel_image_width: int = betterproto.uint32_field(16)
    pixel_image_height: int = betterproto.uint32_field(17)


@dataclass
class SSL_BallModelStraightTwoPhase(betterproto.Message):
    """
    Two-Phase model for straight-kicked balls. There are two phases with
    different accelerations during the ball kicks: 1. Sliding 2. Rolling The
    full model is described in the TDP of ER-Force from 2016, which can be
    found here: https://ssl.robocup.org/wp-
    content/uploads/2019/01/2016_ETDP_ER-Force.pdf
    """

    # Ball sliding acceleration [m/s^2] (should be negative)
    acc_slide: float = betterproto.double_field(1)
    # Ball rolling acceleration [m/s^2] (should be negative)
    acc_roll: float = betterproto.double_field(2)
    # Fraction of the initial velocity where the ball starts to roll
    k_switch: float = betterproto.double_field(3)


@dataclass
class SSL_BallModelChipFixedLoss(betterproto.Message):
    """
    Fixed-Loss model for chipped balls. Uses fixed damping factors for xy and z
    direction per hop.
    """

    # Chip kick velocity damping factor in XY direction for the first hop
    damping_xy_first_hop: float = betterproto.double_field(1)
    # Chip kick velocity damping factor in XY direction for all following hops
    damping_xy_other_hops: float = betterproto.double_field(2)
    # Chip kick velocity damping factor in Z direction for all hops
    damping_z: float = betterproto.double_field(3)


@dataclass
class SSL_GeometryModels(betterproto.Message):
    straight_two_phase: "SSL_BallModelStraightTwoPhase" = betterproto.message_field(1)
    chip_fixed_loss: "SSL_BallModelChipFixedLoss" = betterproto.message_field(2)


@dataclass
class SSL_GeometryData(betterproto.Message):
    field: "SSL_GeometryFieldSize" = betterproto.message_field(1)
    calib: List["SSL_GeometryCameraCalibration"] = betterproto.message_field(2)
    models: "SSL_GeometryModels" = betterproto.message_field(3)


@dataclass
class SSL_WrapperPacket(betterproto.Message):
    detection: "SSL_DetectionFrame" = betterproto.message_field(1)
    geometry: "SSL_GeometryData" = betterproto.message_field(2)


@dataclass
class RobotId(betterproto.Message):
    """RobotId is the combination of a team and a robot id"""

    # the robot number
    id: int = betterproto.uint32_field(1)
    # the team that the robot belongs to
    team: "Team" = betterproto.enum_field(2)


@dataclass
class Vector2(betterproto.Message):
    """A vector with two dimensions"""

    x: float = betterproto.float_field(1)
    y: float = betterproto.float_field(2)


@dataclass
class Vector3(betterproto.Message):
    """A vector with three dimensions"""

    x: float = betterproto.float_field(1)
    y: float = betterproto.float_field(2)
    z: float = betterproto.float_field(3)


@dataclass
class GameEvent(betterproto.Message):
    """
    GameEvent contains exactly one game event Each game event has optional and
    required fields. The required fields are mandatory to process the event.
    Some optional fields are only used for visualization, others are required
    to determine the ball placement position. If fields are missing that are
    required for the ball placement position, no ball placement command will be
    issued. Fields are marked optional to make testing and extending of the
    protocol easier. An autoRef should ideally set all fields, except if there
    are good reasons to not do so.
    """

    type: "GameEventType" = betterproto.enum_field(40)
    # The origins of this game event. Empty, if it originates from game
    # controller. Contains autoRef name(s), if it originates from one or more
    # autoRefs. Ignored if sent by autoRef to game controller.
    origin: List[str] = betterproto.string_field(41)
    ball_left_field_touch_line: "GameEventBallLeftField" = betterproto.message_field(
        6, group="event"
    )
    ball_left_field_goal_line: "GameEventBallLeftField" = betterproto.message_field(
        7, group="event"
    )
    aimless_kick: "GameEventAimlessKick" = betterproto.message_field(11, group="event")
    attacker_too_close_to_defense_area: "GameEventAttackerTooCloseToDefenseArea" = (
        betterproto.message_field(19, group="event")
    )
    defender_in_defense_area: "GameEventDefenderInDefenseArea" = (
        betterproto.message_field(31, group="event")
    )
    boundary_crossing: "GameEventBoundaryCrossing" = betterproto.message_field(
        43, group="event"
    )
    keeper_held_ball: "GameEventKeeperHeldBall" = betterproto.message_field(
        13, group="event"
    )
    bot_dribbled_ball_too_far: "GameEventBotDribbledBallTooFar" = (
        betterproto.message_field(17, group="event")
    )
    bot_pushed_bot: "GameEventBotPushedBot" = betterproto.message_field(
        24, group="event"
    )
    bot_held_ball_deliberately: "GameEventBotHeldBallDeliberately" = (
        betterproto.message_field(26, group="event")
    )
    bot_tipped_over: "GameEventBotTippedOver" = betterproto.message_field(
        27, group="event"
    )
    attacker_touched_ball_in_defense_area: (
        "GameEventAttackerTouchedBallInDefenseArea"
    ) = betterproto.message_field(15, group="event")
    bot_kicked_ball_too_fast: "GameEventBotKickedBallTooFast" = (
        betterproto.message_field(18, group="event")
    )
    bot_crash_unique: "GameEventBotCrashUnique" = betterproto.message_field(
        22, group="event"
    )
    bot_crash_drawn: "GameEventBotCrashDrawn" = betterproto.message_field(
        21, group="event"
    )
    defender_too_close_to_kick_point: "GameEventDefenderTooCloseToKickPoint" = (
        betterproto.message_field(29, group="event")
    )
    bot_too_fast_in_stop: "GameEventBotTooFastInStop" = betterproto.message_field(
        28, group="event"
    )
    bot_interfered_placement: "GameEventBotInterferedPlacement" = (
        betterproto.message_field(20, group="event")
    )
    possible_goal: "GameEventGoal" = betterproto.message_field(39, group="event")
    goal: "GameEventGoal" = betterproto.message_field(8, group="event")
    invalid_goal: "GameEventGoal" = betterproto.message_field(44, group="event")
    attacker_double_touched_ball: "GameEventAttackerDoubleTouchedBall" = (
        betterproto.message_field(14, group="event")
    )
    placement_succeeded: "GameEventPlacementSucceeded" = betterproto.message_field(
        5, group="event"
    )
    penalty_kick_failed: "GameEventPenaltyKickFailed" = betterproto.message_field(
        45, group="event"
    )
    no_progress_in_game: "GameEventNoProgressInGame" = betterproto.message_field(
        2, group="event"
    )
    placement_failed: "GameEventPlacementFailed" = betterproto.message_field(
        3, group="event"
    )
    multiple_cards: "GameEventMultipleCards" = betterproto.message_field(
        32, group="event"
    )
    multiple_fouls: "GameEventMultipleFouls" = betterproto.message_field(
        34, group="event"
    )
    bot_substitution: "GameEventBotSubstitution" = betterproto.message_field(
        37, group="event"
    )
    too_many_robots: "GameEventTooManyRobots" = betterproto.message_field(
        38, group="event"
    )
    challenge_flag: "GameEventChallengeFlag" = betterproto.message_field(
        46, group="event"
    )
    emergency_stop: "GameEventEmergencyStop" = betterproto.message_field(
        47, group="event"
    )
    unsporting_behavior_minor: "GameEventUnsportingBehaviorMinor" = (
        betterproto.message_field(35, group="event")
    )
    unsporting_behavior_major: "GameEventUnsportingBehaviorMajor" = (
        betterproto.message_field(36, group="event")
    )
    # replaced by ready_to_continue flag
    prepared: "GameEventPrepared" = betterproto.message_field(1, group="event")
    # obsolete
    indirect_goal: "GameEventIndirectGoal" = betterproto.message_field(9, group="event")
    # replaced by the meta-information in the possible_goal event
    chipped_goal: "GameEventChippedGoal" = betterproto.message_field(10, group="event")
    # obsolete
    kick_timeout: "GameEventKickTimeout" = betterproto.message_field(12, group="event")
    # rule removed
    attacker_touched_opponent_in_defense_area: (
        "GameEventAttackerTouchedOpponentInDefenseArea"
    ) = betterproto.message_field(16, group="event")
    # obsolete
    attacker_touched_opponent_in_defense_area_skipped: (
        "GameEventAttackerTouchedOpponentInDefenseArea"
    ) = betterproto.message_field(42, group="event")
    # obsolete
    bot_crash_unique_skipped: "GameEventBotCrashUnique" = betterproto.message_field(
        23, group="event"
    )
    # can not be used as long as autoRefs do not judge pushing
    bot_pushed_bot_skipped: "GameEventBotPushedBot" = betterproto.message_field(
        25, group="event"
    )
    # rule removed
    defender_in_defense_area_partially: "GameEventDefenderInDefenseAreaPartially" = (
        betterproto.message_field(30, group="event")
    )
    # the referee msg already indicates this
    multiple_placement_failures: "GameEventMultiplePlacementFailures" = (
        betterproto.message_field(33, group="event")
    )


@dataclass
class GameEventBallLeftField(betterproto.Message):
    """the ball left the field normally"""

    # the team that last touched the ball
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that last touched the ball
    by_bot: int = betterproto.uint32_field(2)
    # the location where the ball left the field [m]
    location: "Vector2" = betterproto.message_field(3)


@dataclass
class GameEventAimlessKick(betterproto.Message):
    """
    the ball left the field via goal line and a team committed an aimless kick
    """

    # the team that last touched the ball
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that last touched the ball
    by_bot: int = betterproto.uint32_field(2)
    # the location where the ball left the field [m]
    location: "Vector2" = betterproto.message_field(3)
    # the location where the ball was last touched [m]
    kick_location: "Vector2" = betterproto.message_field(4)


@dataclass
class GameEventGoal(betterproto.Message):
    """a team shot a goal"""

    # the team that scored the goal
    by_team: "Team" = betterproto.enum_field(1)
    # the team that shot the goal (different from by_team for own goals)
    kicking_team: "Team" = betterproto.enum_field(6)
    # the bot that shot the goal
    kicking_bot: int = betterproto.uint32_field(2)
    # the location where the ball entered the goal [m]
    location: "Vector2" = betterproto.message_field(3)
    # the location where the ball was kicked (for deciding if this was a valid
    # goal) [m]
    kick_location: "Vector2" = betterproto.message_field(4)
    # the maximum height the ball reached during the goal kick (for deciding if
    # this was a valid goal) [m]
    max_ball_height: float = betterproto.float_field(5)
    # number of robots of scoring team when the ball entered the goal (for
    # deciding if this was a valid goal)
    num_robots_by_team: int = betterproto.uint32_field(7)
    # The UNIX timestamp [μs] when the scoring team last touched the ball
    last_touch_by_team: int = betterproto.uint64_field(8)
    # An additional message with e.g. a reason for invalid goals
    message: str = betterproto.string_field(9)


@dataclass
class GameEventIndirectGoal(betterproto.Message):
    """the ball entered the goal directly during an indirect free kick"""

    # the team that tried to shoot the goal
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that kicked the ball - at least the team must be set
    by_bot: int = betterproto.uint32_field(2)
    # the location where the ball entered the goal [m]
    location: "Vector2" = betterproto.message_field(3)
    # the location where the ball was kicked [m]
    kick_location: "Vector2" = betterproto.message_field(4)


@dataclass
class GameEventChippedGoal(betterproto.Message):
    """the ball entered the goal, but was initially chipped"""

    # the team that tried to shoot the goal
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that kicked the ball
    by_bot: int = betterproto.uint32_field(2)
    # the location where the ball entered the goal [m]
    location: "Vector2" = betterproto.message_field(3)
    # the location where the ball was kicked [m]
    kick_location: "Vector2" = betterproto.message_field(4)
    # the maximum height [m] of the ball, before it entered the goal and since
    # the last kick [m]
    max_ball_height: float = betterproto.float_field(5)


@dataclass
class GameEventBotTooFastInStop(betterproto.Message):
    """a bot moved too fast while the game was stopped"""

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that was too fast
    by_bot: int = betterproto.uint32_field(2)
    # the location of the bot [m]
    location: "Vector2" = betterproto.message_field(3)
    # the bot speed [m/s]
    speed: float = betterproto.float_field(4)


@dataclass
class GameEventDefenderTooCloseToKickPoint(betterproto.Message):
    """
    a bot of the defending team got too close to the kick point during a free
    kick
    """

    # the team that was found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that violates the distance to the kick point
    by_bot: int = betterproto.uint32_field(2)
    # the location of the bot [m]
    location: "Vector2" = betterproto.message_field(3)
    # the distance [m] from bot to the kick point (including the minimum radius)
    distance: float = betterproto.float_field(4)


@dataclass
class GameEventBotCrashDrawn(betterproto.Message):
    """two robots crashed into each other with similar speeds"""

    # the bot of the yellow team
    bot_yellow: int = betterproto.uint32_field(1)
    # the bot of the blue team
    bot_blue: int = betterproto.uint32_field(2)
    # the location of the crash (center between both bots) [m]
    location: "Vector2" = betterproto.message_field(3)
    # the calculated crash speed [m/s] of the two bots
    crash_speed: float = betterproto.float_field(4)
    # the difference [m/s] of the velocity of the two bots
    speed_diff: float = betterproto.float_field(5)
    # the angle [rad] in the range [0, π] of the bot velocity vectors an angle of
    # 0 rad (  0°) means, the bots barely touched each other an angle of π rad
    # (180°) means, the bots crashed frontal into each other
    crash_angle: float = betterproto.float_field(6)


@dataclass
class GameEventBotCrashUnique(betterproto.Message):
    """
    two robots crashed into each other and one team was found guilty to due
    significant speed difference
    """

    # the team that caused the crash
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that caused the crash
    violator: int = betterproto.uint32_field(2)
    # the bot of the opposite team that was involved in the crash
    victim: int = betterproto.uint32_field(3)
    # the location of the crash (center between both bots) [m]
    location: "Vector2" = betterproto.message_field(4)
    # the calculated crash speed vector [m/s] of the two bots
    crash_speed: float = betterproto.float_field(5)
    # the difference [m/s] of the velocity of the two bots
    speed_diff: float = betterproto.float_field(6)
    # the angle [rad] in the range [0, π] of the bot velocity vectors an angle of
    # 0 rad (  0°) means, the bots barely touched each other an angle of π rad
    # (180°) means, the bots crashed frontal into each other
    crash_angle: float = betterproto.float_field(7)


@dataclass
class GameEventBotPushedBot(betterproto.Message):
    """a bot pushed another bot over a significant distance"""

    # the team that pushed the other team
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that pushed the other bot
    violator: int = betterproto.uint32_field(2)
    # the bot of the opposite team that was pushed
    victim: int = betterproto.uint32_field(3)
    # the location of the push (center between both bots) [m]
    location: "Vector2" = betterproto.message_field(4)
    # the pushed distance [m]
    pushed_distance: float = betterproto.float_field(5)


@dataclass
class GameEventBotTippedOver(betterproto.Message):
    """a bot tipped over"""

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that tipped over
    by_bot: int = betterproto.uint32_field(2)
    # the location of the bot [m]
    location: "Vector2" = betterproto.message_field(3)
    # the location of the ball at the moment when this foul occurred [m]
    ball_location: "Vector2" = betterproto.message_field(4)


@dataclass
class GameEventDefenderInDefenseArea(betterproto.Message):
    """
    a defender other than the keeper was fully located inside its own defense
    and touched the ball
    """

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that is inside the penalty area
    by_bot: int = betterproto.uint32_field(2)
    # the location of the bot [m]
    location: "Vector2" = betterproto.message_field(3)
    # the distance [m] from bot case to the nearest point outside the defense
    # area
    distance: float = betterproto.float_field(4)


@dataclass
class GameEventDefenderInDefenseAreaPartially(betterproto.Message):
    """
    a defender other than the keeper was partially located inside its own
    defense area and touched the ball
    """

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that is partially inside the penalty area
    by_bot: int = betterproto.uint32_field(2)
    # the location of the bot
    location: "Vector2" = betterproto.message_field(3)
    # the distance [m] that the bot is inside the penalty area
    distance: float = betterproto.float_field(4)
    # the location of the ball at the moment when this foul occurred [m]
    ball_location: "Vector2" = betterproto.message_field(5)


@dataclass
class GameEventAttackerTouchedBallInDefenseArea(betterproto.Message):
    """an attacker touched the ball inside the opponent defense area"""

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that is inside the penalty area
    by_bot: int = betterproto.uint32_field(2)
    # the location of the bot [m]
    location: "Vector2" = betterproto.message_field(3)
    # the distance [m] that the bot is inside the penalty area
    distance: float = betterproto.float_field(4)


@dataclass
class GameEventBotKickedBallTooFast(betterproto.Message):
    """a bot kicked the ball too fast"""

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that kicked too fast
    by_bot: int = betterproto.uint32_field(2)
    # the location of the ball at the time of the highest speed [m]
    location: "Vector2" = betterproto.message_field(3)
    # the absolute initial ball speed (kick speed) [m/s]
    initial_ball_speed: float = betterproto.float_field(4)
    # was the ball chipped?
    chipped: bool = betterproto.bool_field(5)


@dataclass
class GameEventBotDribbledBallTooFar(betterproto.Message):
    """a bot dribbled to ball too far"""

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that dribbled too far
    by_bot: int = betterproto.uint32_field(2)
    # the location where the dribbling started [m]
    start: "Vector2" = betterproto.message_field(3)
    # the location where the maximum dribbling distance was reached [m]
    end: "Vector2" = betterproto.message_field(4)


@dataclass
class GameEventAttackerTouchedOpponentInDefenseArea(betterproto.Message):
    """an attacker touched the opponent robot inside defense area"""

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that touched the opponent robot
    by_bot: int = betterproto.uint32_field(2)
    # the bot of the opposite team that was touched
    victim: int = betterproto.uint32_field(4)
    # the location of the contact point between both bots [m]
    location: "Vector2" = betterproto.message_field(3)


@dataclass
class GameEventAttackerDoubleTouchedBall(betterproto.Message):
    """
    an attacker touched the ball multiple times when it was not allowed to
    """

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that touched the ball twice
    by_bot: int = betterproto.uint32_field(2)
    # the location of the ball when it was first touched [m]
    location: "Vector2" = betterproto.message_field(3)


@dataclass
class GameEventAttackerTooCloseToDefenseArea(betterproto.Message):
    """
    an attacker was located too near to the opponent defense area during stop
    or free kick
    """

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that is too close to the defense area
    by_bot: int = betterproto.uint32_field(2)
    # the location of the bot [m]
    location: "Vector2" = betterproto.message_field(3)
    # the distance [m] of the bot to the penalty area
    distance: float = betterproto.float_field(4)
    # the location of the ball at the moment when this foul occurred [m]
    ball_location: "Vector2" = betterproto.message_field(5)


@dataclass
class GameEventBotHeldBallDeliberately(betterproto.Message):
    """a bot held the ball for too long"""

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that holds the ball
    by_bot: int = betterproto.uint32_field(2)
    # the location of the ball [m]
    location: "Vector2" = betterproto.message_field(3)
    # the duration [s] that the bot hold the ball
    duration: float = betterproto.float_field(4)


@dataclass
class GameEventBotInterferedPlacement(betterproto.Message):
    """a bot interfered the ball placement of the other team"""

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # the bot that interfered the placement
    by_bot: int = betterproto.uint32_field(2)
    # the location of the bot [m]
    location: "Vector2" = betterproto.message_field(3)


@dataclass
class GameEventMultipleCards(betterproto.Message):
    """
    a team collected multiple cards (yellow and red), which results in a
    penalty kick
    """

    # the team that received multiple yellow cards
    by_team: "Team" = betterproto.enum_field(1)


@dataclass
class GameEventMultipleFouls(betterproto.Message):
    """a team collected multiple fouls, which results in a yellow card"""

    # the team that collected multiple fouls
    by_team: "Team" = betterproto.enum_field(1)


@dataclass
class GameEventMultiplePlacementFailures(betterproto.Message):
    """a team failed to place the ball multiple times in a row"""

    # the team that failed multiple times
    by_team: "Team" = betterproto.enum_field(1)


@dataclass
class GameEventKickTimeout(betterproto.Message):
    """timeout waiting for the attacking team to perform the free kick"""

    # the team that that should have kicked
    by_team: "Team" = betterproto.enum_field(1)
    # the location of the ball [m]
    location: "Vector2" = betterproto.message_field(2)
    # the time [s] that was waited
    time: float = betterproto.float_field(3)


@dataclass
class GameEventNoProgressInGame(betterproto.Message):
    """game was stuck"""

    # the location of the ball
    location: "Vector2" = betterproto.message_field(1)
    # the time [s] that was waited
    time: float = betterproto.float_field(2)


@dataclass
class GameEventPlacementFailed(betterproto.Message):
    """ball placement failed"""

    # the team that failed
    by_team: "Team" = betterproto.enum_field(1)
    # the remaining distance [m] from ball to placement position
    remaining_distance: float = betterproto.float_field(2)


@dataclass
class GameEventUnsportingBehaviorMinor(betterproto.Message):
    """a team was found guilty for minor unsporting behavior"""

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # an explanation of the situation and decision
    reason: str = betterproto.string_field(2)


@dataclass
class GameEventUnsportingBehaviorMajor(betterproto.Message):
    """a team was found guilty for major unsporting behavior"""

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # an explanation of the situation and decision
    reason: str = betterproto.string_field(2)


@dataclass
class GameEventKeeperHeldBall(betterproto.Message):
    """a keeper held the ball in its defense area for too long"""

    # the team that found guilty
    by_team: "Team" = betterproto.enum_field(1)
    # the location of the ball [m]
    location: "Vector2" = betterproto.message_field(2)
    # the duration [s] that the keeper hold the ball
    duration: float = betterproto.float_field(3)


@dataclass
class GameEventPlacementSucceeded(betterproto.Message):
    """a team successfully placed the ball"""

    # the team that did the placement
    by_team: "Team" = betterproto.enum_field(1)
    # the time [s] taken for placing the ball
    time_taken: float = betterproto.float_field(2)
    # the distance [m] between placement location and actual ball position
    precision: float = betterproto.float_field(3)
    # the distance [m] between the initial ball location and the placement
    # position
    distance: float = betterproto.float_field(4)


@dataclass
class GameEventPrepared(betterproto.Message):
    """
    both teams are prepared - all conditions are met to continue (with kickoff
    or penalty kick)
    """

    # the time [s] taken for preparing
    time_taken: float = betterproto.float_field(1)


@dataclass
class GameEventBotSubstitution(betterproto.Message):
    """bots are being substituted by a team"""

    # the team that substitutes robots
    by_team: "Team" = betterproto.enum_field(1)


@dataclass
class GameEventChallengeFlag(betterproto.Message):
    """A challenge flag, requested by a team previously, is flagged"""

    # the team that substitutes robots
    by_team: "Team" = betterproto.enum_field(1)


@dataclass
class GameEventEmergencyStop(betterproto.Message):
    """An emergency stop, requested by team previously, occurred"""

    # the team that substitutes robots
    by_team: "Team" = betterproto.enum_field(1)


@dataclass
class GameEventTooManyRobots(betterproto.Message):
    """a team has too many robots on the field"""

    # the team that has too many robots
    by_team: "Team" = betterproto.enum_field(1)
    # number of robots allowed at the moment
    num_robots_allowed: int = betterproto.int32_field(2)
    # number of robots currently on the field
    num_robots_on_field: int = betterproto.int32_field(3)
    # the location of the ball at the moment when this foul occurred [m]
    ball_location: "Vector2" = betterproto.message_field(4)


@dataclass
class GameEventBoundaryCrossing(betterproto.Message):
    """
    a robot chipped the ball over the field boundary out of the playing surface
    """

    # the team that has too many robots
    by_team: "Team" = betterproto.enum_field(1)
    # the location of the ball [m]
    location: "Vector2" = betterproto.message_field(2)


@dataclass
class GameEventPenaltyKickFailed(betterproto.Message):
    """the penalty kick failed (by time or by keeper)"""

    # the team that last touched the ball
    by_team: "Team" = betterproto.enum_field(1)
    # the location of the ball at the moment of this event [m]
    location: "Vector2" = betterproto.message_field(2)


@dataclass
class Referee(betterproto.Message):
    """Each UDP packet contains one of these messages."""

    # The UNIX timestamp when the packet was sent, in microseconds. Divide by
    # 1,000,000 to get a time_t.
    packet_timestamp: int = betterproto.uint64_field(1)
    stage: "RefereeStage" = betterproto.enum_field(2)
    # The number of microseconds left in the stage. The following stages have
    # this value; the rest do not: NORMAL_FIRST_HALF NORMAL_HALF_TIME
    # NORMAL_SECOND_HALF EXTRA_TIME_BREAK EXTRA_FIRST_HALF EXTRA_HALF_TIME
    # EXTRA_SECOND_HALF PENALTY_SHOOTOUT_BREAK If the stage runs over its
    # specified time, this value becomes negative.
    stage_time_left: int = betterproto.sint32_field(3)
    command: "RefereeCommand" = betterproto.enum_field(4)
    # The number of commands issued since startup (mod 2^32).
    command_counter: int = betterproto.uint32_field(5)
    # The UNIX timestamp when the command was issued, in microseconds. This value
    # changes only when a new command is issued, not on each packet.
    command_timestamp: int = betterproto.uint64_field(6)
    # Information about the two teams.
    yellow: "RefereeTeamInfo" = betterproto.message_field(7)
    blue: "RefereeTeamInfo" = betterproto.message_field(8)
    designated_position: "RefereePoint" = betterproto.message_field(9)
    # Information about the direction of play. True, if the blue team will have
    # it's goal on the positive x-axis of the ssl-vision coordinate system.
    # Obviously, the yellow team will play on the opposite half.
    blue_team_on_positive_half: bool = betterproto.bool_field(10)
    # The command that will be issued after the current stoppage and ball
    # placement to continue the game.
    next_command: "RefereeCommand" = betterproto.enum_field(12)
    game_events: List["GameEvent"] = betterproto.message_field(16)
    game_event_proposals: List["GameEventProposalGroup"] = betterproto.message_field(17)
    # The time in microseconds that is remaining until the current action times
    # out The time will not be reset. It can get negative. An autoRef would raise
    # an appropriate event, if the time gets negative. Possible actions where
    # this time is relevant:  * free kicks  * kickoff, penalty kick, force start
    # * ball placement
    current_action_time_remaining: int = betterproto.int32_field(15)


@dataclass
class RefereeTeamInfo(betterproto.Message):
    """Information about a single team."""

    # The team's name (empty string if operator has not typed anything).
    name: str = betterproto.string_field(1)
    # The number of goals scored by the team during normal play and overtime.
    score: int = betterproto.uint32_field(2)
    # The number of red cards issued to the team since the beginning of the game.
    red_cards: int = betterproto.uint32_field(3)
    # The amount of time (in microseconds) left on each yellow card issued to the
    # team. If no yellow cards are issued, this array has no elements. Otherwise,
    # times are ordered from smallest to largest.
    yellow_card_times: List[int] = betterproto.uint32_field(4)
    # The total number of yellow cards ever issued to the team.
    yellow_cards: int = betterproto.uint32_field(5)
    # The number of timeouts this team can still call. If in a timeout right now,
    # that timeout is excluded.
    timeouts: int = betterproto.uint32_field(6)
    # The number of microseconds of timeout this team can use.
    timeout_time: int = betterproto.uint32_field(7)
    # The pattern number of this team's goalkeeper.
    goalkeeper: int = betterproto.uint32_field(8)
    # The total number of countable fouls that act towards yellow cards
    foul_counter: int = betterproto.uint32_field(9)
    # The number of consecutive ball placement failures of this team
    ball_placement_failures: int = betterproto.uint32_field(10)
    # Indicate if the team is able and allowed to place the ball
    can_place_ball: bool = betterproto.bool_field(12)
    # The maximum number of bots allowed on the field based on division and cards
    max_allowed_bots: int = betterproto.uint32_field(13)
    # The team has submitted an intent to substitute one or more robots at the
    # next chance
    bot_substitution_intent: bool = betterproto.bool_field(14)
    # Indicate if the team reached the maximum allowed ball placement failures
    # and is thus not allowed to place the ball anymore
    ball_placement_failures_reached: bool = betterproto.bool_field(15)


@dataclass
class RefereePoint(betterproto.Message):
    """
    The coordinates of the Designated Position. These are measured in
    millimetres and correspond to SSL-Vision coordinates. These fields are
    always either both present (in the case of a ball placement command) or
    both absent (in the case of any other command).
    """

    x: float = betterproto.float_field(1)
    y: float = betterproto.float_field(2)


@dataclass
class GameEventProposalGroup(betterproto.Message):
    """List of matching proposals"""

    # The proposed game event.
    game_event: List["GameEvent"] = betterproto.message_field(1)
    # Whether the proposal group was accepted
    accepted: bool = betterproto.bool_field(2)
